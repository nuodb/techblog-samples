/****************************************************************************
 * Copyright (c) 2013, NuoDB, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of NuoDB, Inc. nor the names of its contributors may
 *       be used to endorse or promote products derived from this software
 *       without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL NUODB, INC. BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ****************************************************************************/

package com.nuodb.diff;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * A DiffEngine computes a longest common subsequence matrix
 * for two sequences of elements, and backtracks through that
 * matrix to construct a List of edit operations to transform
 * sequenceA into sequenceB.
 */
public class DiffEngine<T extends Comparable<T>>
{
    /**
     * Construct the LCS table for two sequences.
     * @param sequenceA the first sequence.
     * @param sequenceB the second sequence.
     */
    public DiffEngine(List<T> sequenceA, List<T> sequenceB)
    {
        this.sequenceA  = sequenceA;
        this.sequenceB  = sequenceB;
        computeLcs();
    }

    private final List<T> sequenceA;
    private final List<T> sequenceB;

    /**
     * The longest common subsequence of the two sequences,
     * encoded as a matrix of longest common subsequences
     * of prefixes to the two sequences.
     */
    private int[][] lcs;

    /**
     * Compute the longest common subsequence of the two sequences
     * by computing the longest common subsequences of the prefixes
     * a[1..i],b[1..j] for 0 &lt; 1 &lt; size(a), 0 &lt; j &lt; size(b).
     * Note that the algorithm uses one-based addressing.
     */
    private void computeLcs()
    {
        // The 0th row and column are the initial conditions,
        // which are are initialized to 0 by side effect.
        lcs = new int[sequenceA.size()+1][sequenceB.size()+1];

        for (int i = 0; i < sequenceA.size(); i++) {

            for (int j = 0; j < sequenceB.size(); j++) {

                if (sequenceA.get(i).compareTo(sequenceB.get(j)) == 0) {
                    // The subsequence extends to the ith and jth 
                    // positions of the respective strings.
                    lcs[i+1][j+1] = lcs[i][j] + 1;
                } else {
                    // The longest subsequence at the ith and jth
                    // positions is the longest of the two subsequences
                    // of the prefixes sequenceA[1..i-1], sequenceB[1..j-1].
                    lcs[i+1][j+1] = Math.max(lcs[i][j+1], lcs[i+1][j]);
                }
            }
        }
    }

    /**
     * Backtrace the LCS matrix and generate a sequence of edit operations
     * that will transform sequence A to sequence B. Note that the results
     * generated by this algorithm are not necessarily the only valid sequence.
     * @return a list of element-by-element differences.
     */
    public List<Difference> getDifferences()
    {
        List<Difference> differences = new ArrayList<Difference>();

        // Process the two sequences back-to-front to operate on
        // progressive prefixes.
        int i = sequenceA.size();
        int j = sequenceB.size();

        while (i > 0 || j > 0) {

            if (i > 0 && j > 0 && sequenceA.get(i-1).compareTo(sequenceB.get(j-1)) == 0) {

                // This element is common to both sequences, no editing required.
                i--;
                j--;

            } else if (j > 0 && (i == 0 || lcs[i][j-1] >= lcs[i-1][j])) {

                // This element is not common to both prefixes a[1..i],b[1..j],
                // so we have to edit it and continue searching prefixes
                // a[1..i],b[1..j-1] or a[1..i-1],b[1..j].  The LCS of a[1..i],b[1..j-1]
                // is at least as long as the LCS of the prefixes a[1..i-1],b[1..j],
                // so continuing with prefixes a[1..i],b[1..j-1] is valid;
                // this would remove the element from sequence b, but by convention
                // we're emitting edits to change sequence a to sequence b, 
                // so the edit operation generated is an insert.
                differences.add(new Difference(i,j, Difference.EditType.Insert, sequenceB.get(j-1)));
                j--;

            } else {

                // TODO: Explain why this condition is known to hold.
                assert (i > 0 && (j == 0 || lcs[i][j-1] < lcs[i-1][j]));

                // Since this final branch covers... 
                differences.add(new Difference(i,j, Difference.EditType.Remove, sequenceA.get(i-1)));
                i--;
            }
        }

        // Backtracing generates the list from back to front,
        // so reverse it to get front-to-back.
        Collections.reverse(differences);

        return differences;
    }

    /**
     * Coalesce a list of line-by-line Differences into larger regions.
     * @param diff the list of Differences.
     * @return a list of Coalescible regions.
     */
    public static List<Object> coalesceRegions(List<Difference> diffs)
    {
        List<Object> result = new ArrayList<Object>();

        if (diffs.size() > 0) {

            Coalescible previous = diffs.get(0);

            for (int i = 1; i < diffs.size(); i++) {

                Difference diff = diffs.get(i);

                if (previous.canCoalesce(diff)) {
                    previous = previous.coalesce(diff);
                } else {
                    // The next diff is unrelated to the previous sequence of diffs;
                    // add the previous sequence to the result and start a new sequence.
                    result.add(previous);
                    previous = diff;
                }
            }

            result.add(previous);
        }

        return result;
    }
    
}
